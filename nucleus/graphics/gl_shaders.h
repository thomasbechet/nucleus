#ifndef NUGL_SHADERS_H
#define NUGL_SHADERS_H
#include <nucleus/core/config.h>
static const nu_char_t *nugl__shader_blit_frag = 
"#version 330 core\n"
"\n"
"out vec4 out_color;\n"
"in vec2 uv;\n"
"\n"
"uniform sampler2D t_surface;\n"
"\n"
"vec2 uv_filtering(in vec2 uv, in vec2 texture_size)\n"
"{\n"
"    vec2 pixel = uv * texture_size;\n"
"    vec2 seam = floor(pixel + 0.5);\n"
"    vec2 dudv = fwidth(pixel);\n"
"    vec2 rel = (pixel - seam) / dudv;\n"
"    vec2 mid_pix = vec2(0.5);\n"
"    pixel = seam + clamp(rel, -mid_pix, mid_pix);\n"
"    return pixel / texture_size;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    // vec2 uv = uv_filtering(in_uv, textureSize(t_surface, 0));\n"
"    out_color = texture(t_surface, uv);\n"
"}\n"
;
static const nu_char_t *nugl__shader_blit_vert = 
"#version 330 core\n"
"\n"
"out vec2 uv;\n"
"\n"
"void main()\n"
"{\n"
"    float x = float((gl_VertexID & 1) << 2);\n"
"    float y = float((gl_VertexID & 2) << 1);\n"
"\n"
"    uv.x = x * 0.5;\n"
"    uv.y = y * 0.5;\n"
"\n"
"    gl_Position = vec4(x - 1.0, y - 1.0, 0.0, 1.0);\n"
"}\n"
;
static const nu_char_t *nugl__shader_flat_frag = 
"#version 330 core\n"
"\n"
"in vec2 uv;\n"
"in vec3 normal;\n"
"out vec4 color;\n"
"\n"
"uniform sampler2D texture0;\n"
"\n"
"void main()\n"
"{\n"
"    color = texture(texture0, uv);\n"
"    color *= max(0, dot(normal, normalize(vec3(1))));\n"
"    color += vec4(1) * 0.05;\n"
"}\n"
;
static const nu_char_t *nugl__shader_flat_vert = 
"#version 330 core\n"
"\n"
"layout(location = 0) in vec3 in_position;\n"
"layout(location = 1) in vec2 in_uv;\n"
"layout(location = 2) in vec3 in_normal;\n"
"\n"
"uniform uvec2 viewport_size;\n"
"uniform mat4 model;\n"
"uniform mat4 view_projection;\n"
"uniform mat3 uv_transform;\n"
"\n"
"out vec2 uv;\n"
"out vec3 normal;\n"
"\n"
"void main()\n"
"{\n"
"    // Transform vertex\n"
"    vec4 position = view_projection * model * vec4(in_position, 1);\n"
"\n"
"    // Prevent sub pixel aliasing by flooring vertices to pixel\n"
"    vec2 grid = vec2(viewport_size);\n"
"    position.xyz = position.xyz / position.w;\n"
"    position.xy = floor(grid * position.xy) / grid;\n"
"    position.xyz *= position.w;\n"
"\n"
"    gl_Position = position;\n"
"\n"
"    // Apply user transformation to uv\n"
"    uv = (uv_transform * vec3(in_uv, 1)).xy;\n"
"\n"
"    normal = mat3(transpose(inverse(model))) * in_normal;\n"
"}\n"
;
#endif
